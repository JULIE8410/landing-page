---
sidebar_position: 10
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import PropTable from "../../src/components/table/PropTable.js";
import DataAttributeTable from "../../src/components/table/DataAttributeTable.js";
import formAPI from "../data/form.ts";
import FormDemo from "../../src/components/core-components/FormDemo.jsx";

# Form

유효성 검사 규칙을 사용하여 사용자로부터 정보를 수집합니다.

<FormDemo />

<Tabs>
<TabItem value="js" label="index.js">

```jsx
import React from "react";
import * as Form from "@radix-ui/react-form";
import "./styles.css";

const FormDemo = () => (
  <Form.Root className="FormRoot">
    <Form.Field className="FormField" name="email">
      <div
        style={{
          display: "flex",
          alignItems: "baseline",
          justifyContent: "space-between",
        }}
      >
        <Form.Label className="FormLabel">Email</Form.Label>
        <Form.Message className="FormMessage" match="valueMissing">
          Please enter your email
        </Form.Message>
        <Form.Message className="FormMessage" match="typeMismatch">
          Please provide a valid email
        </Form.Message>
      </div>
      <Form.Control asChild>
        <input className="Input" type="email" required />
      </Form.Control>
    </Form.Field>
    <Form.Field className="FormField" name="question">
      <div
        style={{
          display: "flex",
          alignItems: "baseline",
          justifyContent: "space-between",
        }}
      >
        <Form.Label className="FormLabel">Question</Form.Label>
        <Form.Message className="FormMessage" match="valueMissing">
          Please enter a question
        </Form.Message>
      </div>
      <Form.Control asChild>
        <textarea className="Textarea" required />
      </Form.Control>
    </Form.Field>
    <Form.Submit asChild>
      <button className="Button" style={{ marginTop: 10 }}>
        Post question
      </button>
    </Form.Submit>
  </Form.Root>
);

export default FormDemo;
```

</TabItem>
<TabItem value="css" label="styles.css">

```css
@import "@radix-ui/colors/black-alpha.css";
@import "@radix-ui/colors/violet.css";
@import "@radix-ui/colors/mauve.css";

/* reset */
input,
textarea,
button {
  all: unset;
  box-sizing: border-box;
}

.FormRoot {
  width: 260px;
}

.FormField {
  display: grid;
  margin-bottom: 10px;
}

.FormLabel {
  font-size: 15px;
  font-weight: 500;
  line-height: 35px;
  color: white;
}

.FormMessage {
  font-size: 13px;
  color: white;
  opacity: 0.8;
}

.Input,
.Textarea {
  width: 100%;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  border-radius: 4px;

  font-size: 15px;
  color: white;
  background-color: var(--black-a5);
  box-shadow: 0 0 0 1px var(--black-a9);
}
.Input:hover,
.Textarea:hover {
  box-shadow: 0 0 0 1px black;
}
.Input:focus,
.Textarea:focus {
  box-shadow: 0 0 0 2px black;
}
.Input::selection,
.Textarea::selection {
  background-color: var(--black-a9);
  color: white;
}

.Input {
  padding: 0 10px;
  height: 35px;
  line-height: 1;
}

.Textarea {
  resize: none;
  padding: 10px;
}

.Button {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  border-radius: 4px;
  padding: 0 15px;
  font-size: 15px;
  line-height: 1;
  font-weight: 500;
  height: 35px;
  width: 100%;

  background-color: white;
  color: var(--violet-11);
  box-shadow: 0 2px 10px var(--black-a7);
}
.Button:hover {
  background-color: var(--mauve-3);
}
.Button:focus {
  box-shadow: 0 0 0 2px black;
}
```

</TabItem>
</Tabs>

## 특징

![checkbox icon](../../static/img/checkboxicon.png) Native browser [`constraint validation API`](https://developer.mozilla.org/en-US/docs/Web/HTML/Constraint_validation) 위에 구축

![checkbox icon](../../static/img/checkboxicon.png) 내장 유효성 검사를 지원

![checkbox icon](../../static/img/checkboxicon.png) 사용자 지정 유효성 검사를 지원

![checkbox icon](../../static/img/checkboxicon.png) 유효성 검사 메시지의 전체 사용자 지정

![checkbox icon](../../static/img/checkboxicon.png) 액세스 가능한 유효성 확인 메시지

![checkbox icon](../../static/img/checkboxicon.png) 클라이언트 측 및 서버 측 시나리오를 지원

![checkbox icon](../../static/img/checkboxicon.png) 포커스의 완벽한 관리

export const Highlight = ({ children, color }) => (
  <span style={{ color: color }}>{children}</span>
);

## <Highlight color='#1C5AEC'>설치</Highlight>

커맨드라인에서 컴포넌트를 설치하세요.

```bash
npm install @radix-ui/react-form
```

## <Highlight color='#1C5AEC'>구성</Highlight>

모든 구성요소를 가져와서 조합하세요.

```jsx
import * as Form from "@radix-ui/react-form";

export default () => (
  <Form.Root>
    <Form.Field>
      <Form.Label />
      <Form.Control />
      <Form.Message />
      <Form.ValidityState />
    </Form.Field>

    <Form.Message />
    <Form.ValidityState />

    <Form.Submit />
  </Form.Root>
);
```

## <Highlight color='#1C5AEC'>API 참조</Highlight>

### <Highlight color='#1C5AEC'>Root</Highlight>

Form의 모든 부분을 포함합니다.

<PropTable api={formAPI} category="root" />

### <Highlight color='#1C5AEC'>Field</Highlight>

필드의 wrapper입니다. ID/이름 및 레이블 접근성을 자동으로 처리합니다.

<PropTable api={formAPI} category="field" />
<DataAttributeTable api={formAPI} category="field" />

### <Highlight color='#1C5AEC'>Label</Highlight>

`Field` 부분 안에 중첩될 때 자동으로 연결되는 레이블 요소입니다.

<PropTable api={formAPI} category="label" />
<DataAttributeTable api={formAPI} category="label" />

### <Highlight color='#1C5AEC'>Control</Highlight>

`Field` 부분 안에 중첩될 때 자동으로 결합되는 제어 요소(기본적으로 `input`)입니다.

<PropTable api={formAPI} category="control" />
<DataAttributeTable api={formAPI} category="control" />

### <Highlight color='#1C5AEC'>Message</Highlight>

`Field` 부분 내부에 중첩될 때 지정된 컨트롤에 자동으로 결합(기능성 및 접근성)되는 유효성 검사 메시지입니다.
기본 제공 및 사용자 지정 클라이언트 측 유효성 검사뿐만 아니라 서버 측 유효성 검사에도 사용할 수 있습니다.
`Field` 외부에서 사용할 경우 필드와 일치하는 `name prop`을 전달해야 합니다.
`Form.Message`는 메시지가 표시되어야 하는 시기를 결정하는 데 사용되는 `match prop`을 받아들입니다.
이는 native HTML 유효성 상태(`ValidityState` on [`MDN`](https://developer.mozilla.org/en-US/docs/Web/API/ValidityState))와 일치하며,
이 상태는 `required`, `min`, `max`와 같은 속성에 대해 유효성을 갖습니다.
주어진 `match`가 컨트롤의 유효성 상태에서 `true`인지 메시지가 표시됩니다.
일치시킬 함수를 `match`에 전달하여 사용자 지정 유효성 검사 규칙을 제공할 수도 있습니다.

<PropTable api={formAPI} category="message" />

### <Highlight color='#1C5AEC'>ValidityState</Highlight>

이 render-prop 컴포넌트를 사용하여 렌더에서 지정된 필드의 유효성 상태에 액세스할 수 있습니다([`MDN`](https://developer.mozilla.org/en-US/docs/Web/API/ValidityState)의 유효성 상태 참조).
`Field`의 유효성은 필드 부분 안에 중첩될 때 자동으로 사용할 수 있으며, 그렇지 않으면 `name prop`을 전달하여 연결해야 합니다.

<PropTable api={formAPI} category="validitystte" />

### <Highlight color='#1C5AEC'>Submit</Highlight>

제출버튼입니다.

<PropTable api={formAPI} category="submit" />

## <Highlight color='#1C5AEC'>예</Highlight>

#### 자신만의 구성요소로 구성

`asChild`를 사용하면 `Form` Primitive 부분을 자신의 구성요소로 구성할 수 있습니다.

```jsx
<Form.Field name="name">
  <Form.Label>Full name</Form.Label>
  <Form.Control asChild>
    <TextField.Input variant="primary" />
  </Form.Control>
</Form.Field>
```

It can also be used to compose other types of controls, such as a `select`:

```jsx
<Form.Field name="country">
  <Form.Label>Country</Form.Label>
  <Form.Control asChild>
    <select>
      <option value="uk">United Kingdom</option>…
    </select>
  </Form.Control>
</Form.Field>
```

Note: At the moment, it is not possible to compose `Form` with Radix's other form primitives such as `Checkbox`, `Select`, etc.
We are working on a solution for this.

#### 사용자 고유의 검증 메시지 제공

`children`이 없는 경우 `Form.Message`는 지정된 `match`에 대한 기본 오류 메시지를 렌더링합니다.

```jsx
// will yield "This value is missing"
<Form.Message match="missingValue" />
```

자신의 고유 `children`을 물려줌으로써 보다 의미 있는 메시지를 전달할 수 있으며, 이는 국제화에도 유용합니다.

```jsx
// will yield "Please provide a name"
<Form.Message match="missingValue">Please provide a name</Form.Message>
```

#### 사용자 정의 유효성 검사

위에서 설명한 기본 제공 클라이언트 측 검증 일치 외에도 플랫폼의 검증 능력을 활용하여 자체 맞춤형 검증을 제공할 수 있으며 c
`onstraint validition API`에 존재하는 `customError` 유형을 사용합니다.
`Form.Message`에서 자신의 검증 기능을 `match` prop에 전달할 수 있습니다.
다음은 예입니다:

```jsx
<Form.Field name="name">
  <Form.Label>Full name</Form.Label>
  <Form.Control />
  <Form.Message match={(value, formData) => value !== "John"}>
    Only John is allowed.
  </Form.Message>
</Form.Field>
```

`match`는 첫 번째 인수로 컨트롤의 현재 값을 호출하고 두 번째 인수로 전체 `FormData`를 호출합니다.
`match`는 비동기 유효성 검사를 수행하기 위한 비동기 함수(또는 약속을 반환)일 수도 있습니다

#### 유효성에 따른 스타일링

관련 부분에 `data-valid` 속성과 `data-valid` 속성을 추가합니다. 이를 사용하여 당신의 컴포넌트에 맞게 스타일링 할 수 있습니다.
다음은 `Label` 영역을 스타일링 하는 예입니다

```jsx
//index.jsx
import * as React from "react";
import Form from "@radix-ui/react-form";

export default () => (
  <Form.Root>
    <Form.Field name="email">
      <Form.Label className="FormLabel">Email</Form.Label>
      <Form.Control type="email" />
    </Form.Field>
  </Form.Root>
);
```

```css
/* styles.css */
.FormLabel[data-invalid] {
  color: red;
}
.FormLabel[data-valid] {
  color: green;
}
```

#### 더 많은 제어를 위해 유효성 상태에 액세스하는 중

자신의 아이콘을 표시하거나 정의된 도구를 통해 구성요소 라이브러리와 인터페이스하려면 필드의 원시 유효성 상태에 액세스해야 할 수 있습니다.
`Form.ValidityState` 파트를 사용하여 이 작업을 수행할 수 있습니다:

```jsx
<Form.Field name="name">
  <Form.Label>Full name</Form.Label>
  <Form.ValidityState>
    {(validity) => (
      <Form.Control asChild>
        <TextField.Input
          variant="primary"
          state={getTextFieldInputState(validity)}
        />
      </Form.Control>
    )}
  </Form.ValidityState>
</Form.Field>
```

#### 서버측 유효성 검사

구성 요소는 동일한 `Form.Message` 구성 요소를 사용하여 서버측 유효성 검사도 지원합니다.
클라이언트측 일치 로직에 관계없이 메시지가 표시되도록 강제하는 `forceMatch` prop을 전달하여 클라이언트측 오류에 대해 정의한 동일한 메시지를 다시 사용할 수 있습니다.
클라이언트 측에 메시지가 없는 경우 `match`가 없이도 `Form.Message`를 렌더링할 수 있습니다.
이 필드는 `Form.Field` 부분에 `server Invalid` boolean prop를 전달하여 잘못된 것으로 표시됩니다.
서버측 오류 처리의 예는 다음과 같습니다:

```jsx
import * as React from "react";
import * as Form from "@radix-ui/react-form";

function Page() {
  const [serverErrors, setServerErrors] = React.useState({
    email: false,
    password: false,
  });

  return (
    <Form.Root
      // `onSubmit` only triggered if it passes client-side validation
      onSubmit={(event) => {
        const data = Object.fromEntries(new FormData(event.currentTarget));

        // Submit form data and catch errors in the response
        submitForm(data)
          .then(() => {})
          /**
           * Map errors from your server response into a structure you'd like to work with.
           * In this case resulting in this object: `{ email: false, password: true }`
           */
          .catch((errors) => setServerErrors(mapServerErrors(errors)));

        // prevent default form submission
        event.preventDefault();
      }}
      onClearServerErrors={() =>
        setServerErrors({ email: false, password: false })
      }
    >
      <Form.Field name="email" serverInvalid={serverErrors.email}>
        <Form.Label>Email address</Form.Label>
        <Form.Control type="email" required />
        <Form.Message match="valueMissing">
          Please enter your email.
        </Form.Message>
        <Form.Message match="typeMismatch" forceMatch={serverErrors.email}>
          Please provide a valid email.
        </Form.Message>
      </Form.Field>

      <Form.Field name="password" serverInvalid={serverErrors.password}>
        <Form.Label>Password</Form.Label>
        <Form.Control type="password" required />
        <Form.Message match="valueMissing">
          Please enter a password.
        </Form.Message>
        {serverErrors.password && (
          <Form.Message>
            Please provide a valid password. It should contain at least 1 number
            and 1 special character.
          </Form.Message>
        )}
      </Form.Field>

      <Form.Submit>Submit</Form.Submit>
    </Form.Root>
  );
}
```

`Form.Root` 부분의 `onClearServerErrors` callback prop을 사용하여 서버 오류를 지워야 합니다.
양식이 다시 제출되기 전에, 양식이 재설정되면 서버 오류를 지웁니다.
또한, 단일 서버 오류를 재설정할 수 있는 컨트롤을 제공합니다.
예를 들어 사용자가 전자 메일 서버 오류를 편집하는 즉시 재설정할 수 있습니다:

```jsx
<Form.Field name="email" serverInvalid={serverErrors.email}>
  <Form.Label>Email address</Form.Label>
  <Form.Control
    type="email"
    onChange={() => setServerErrors((prev) => ({ ...prev, email: false }))}
  />
  <Form.Message match="missingValue">Please enter your email.</Form.Message>
  <Form.Message match="typeMismatch" forceMatch={serverErrors.email}>
    Please provide a valid email.
  </Form.Message>
</Form.Field>
```

## <Highlight color='#1C5AEC'>접근성</Highlight>

이 컴포넌트는 유효성 검사를 위해 "inline errors" 패턴을 따릅니다:

ㅇ `Form.Field`에 제공된 `name`을 사용하여 레이블과 컨트롤이 연결됩니다.

ㅇ 하나 이상의 클라이언트 측 오류 메시지가 표시되면 일치하는 컨트롤과 자동으로 연결되어 그에 따라 공지됩니다.

ㅇ 포커스가 첫 번째 유효하지 않은 컨트롤로 이동됩니다.
